package com.example.artem.cw;

import android.app.Service;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.support.annotation.Nullable;

/**
 * Created by Artem on 09.09.2016.
 */
public class SocketClient extends Service { // позволяет другим приложениям привязываться к нему и взаимодействовать с ним.

    String mail;

    //Если служба является частной и предоставляется в рамках вашего собственного приложения, а также выполняется в том же процессе, что и клиент (общий процесс),
    // создавать интерфейс следует путем расширения класса Binder и возврата его экземпляра из метода onBind(). Клиент получает объект Binder, после чего он может
    // использовать его для получения прямого доступа к общедоступным методам, имеющимся либо в реализации Binder, либо даже в Service.
    public class LocalBinder extends Binder {
        SocketClient getService() {
            return SocketClient.this;
        }
    }

    //Если необходимо, чтобы операция получала ответы даже в случае ее остановки во время работы в фоновом режиме, то привязку можно выполнить во время onCreate(), 
    // а отмену привязки — во время выполнения onDestroy().


    //В Java существует ключевое слово super, которое обозначает суперкласс, т.е. класс, производным от которого является текущий класс. Посмотрим, зачем это нужно.
    //Ключевое слово super можно использовать для вызова конструктора суперкласса и для обращения к члену суперкласса, скрытому членом подкласса

    //Вторая форма ключевого слова super действует подобно ключевому слову this, только при этом мы всегда ссылаемся на суперкласс подкласса, в котором она использована.
    // Общая форма имеет следующий вид: super.член

    @Override
    public void onCreate() {
        super.onCreate();
        
        startService();
    }

    @Override
    //Чтобы обеспечить привязку службы , сначала необходимо реализовать метод обратного вызова onBind().
    //Этот метод возвращает объект IBinder. Он определяет программный интерфейс, с помощью которого клиенты могут взаимодействовать со службой.
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    @Override
    public void onDestroy() {}

    //Тут инициализирую нужные значения и открываю сокет соединение

    //можно создать службу, которая одновременно и запущена, и привязана. Это означает, что службу можно запустить путем вызова метода startService(),
    // который позволяет службе работать неограниченное время, а также позволяет клиентам привязываться к ней с помощью вызова метода bindService().

    private void startService() {
        mail = "temik_romanov@mail.ru";

        try {
            openConnection();
        } catch (InterruptedException e) { // InterruptedException — это checked exception генерируемый многими методами стандартной библиотеки, которые блокируют поток исполнения.
                                            // По своей сути, InterruptedException сигнализирует о том, что поток просят завершить его работу. При этом вас не просят немедленно завершить свою работу. Вас просят корректно завершить работу. На это может понадобится некоторое время
        e.printStackTrace(); //Печатает Throwable и трассировку вызовов Throwable. Вызов стека показывает последовательность вызовов методов, которые подвели вас к точке, в которой было выброшено исключение. Первая версия печатает в поток стандартный поток ошибки. // Запись информации в этот Throwable объекте о текущем состоянии кадра стека.
        }
        }

    // метод открыает соединение
    private void openConnection() throws InterruptedException //Системные исключения автоматически передаются самой системой. Чтобы передать исключение вручную, используется throw.
    {
        try {
            // WatchData - это класс, с помощью которого мы передадим параметры в
            // создаваемый поток
            WatchData data = new WatchData();
            data.email = mail;
            data.ctx = this;

            // создаём новый поток для сокет соединения
            new WatchSocket().execute(data);

        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();

        }
    }
}
